type ActivityLineItem {
  description: String!
  createdAt: DateTime!
}

type ActivityLineItemEdge {
  cursor: String!
  node: ActivityLineItem!
}

type ActivityLineItemConnection {
  edges: [ActivityLineItemEdge]
  pageInfo: PageInfo!
}

type Alert {
  text: String!
  type: AlertType!
  id: String!
}

interface Alertable {
  alerts: [Alert!]!
}

enum AlertType {
  SUCCESS
  WARN
  ERROR
}

scalar Color

input CreateGithubSessionInput {
  clientMutationId: String
  githubAvatarUrl: String!
  githubUsername: String!
  name: String!
  primaryEmail: String!
  serverSecret: String!
}

input CreateGoogleSessionInput {
  clientMutationId: String
  googleAvatarUrl: String!
  googleProfileId: String!
  name: String!
  primaryEmail: String!
  serverSecret: String!
}

type CreateSessionPayload implements Alertable {
  alerts: [Alert!]!
  userEdge: UserEdge
  sessionEdge: SessionEdge
}

scalar DateTime

input DeleteAccountInput {
  clientMutationId: String
  userId: ID!
}

type DeleteAccountPayload implements Alertable {
  alerts: [Alert!]!
  clientMutationId: String
  deletedUserId: ID!
}

input DeleteLinkInput {
  clientMutationId: String
  linkId: String!
  repoId: String!
}

type DeleteLinkPayload {
  clientMutationId: String
  deletedLinkId: String
}

input DeleteSessionInput {
  clientMutationId: String
  sessionId: ID!
}

type DeleteSessionPayload {
  clientMutationId: String
  deletedSessionId: ID
}

input DeleteTopicInput {
  clientMutationId: String
  repoId: String!
  topicId: String!
}

type DeleteTopicPayload {
  clientMutationId: String
  deletedTopicId: String
}

input RemoveTopicTimerangeInput {
  clientMutationId: String
  repoId: String!
  topicId: String!
}

type RemoveTopicTimerangePayload {
  clientMutationId: String
  topic: Topic!
}

type Link implements Namespaceable {
  availableParentTopics(
    searchString: String,
  ): LiveSearchTopicsPayload!
  createdAt: DateTime!
  displayColor: Color!
  id: String!
  loading: Boolean!
  newlyAdded: Boolean!
  organization: Organization!
  parentTopics(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
  # repository: Repository!
  sha1: String!
  title: String!
  updatedAt: DateTime!
  url: String!
  viewerCanUpdate: Boolean!
  viewerReview: LinkReview
}

type LinkEdge {
  cursor: String!
  node: Link!
}

type LinkConnection {
  edges: [LinkEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum LocaleIdentifier {
  ar
  de
  el
  en
  es
  fa
  fi
  fr
  hi
  it
  ja
  ji
  ko
  la
  nl
  no
  pt
  ru
  sv
  tr
  uk
  zh
}

type LinkReview {
  reviewedAt: DateTime
  user: User!
}

type SynonymMatch {
  displayName: String!
  id: String!
}

type LiveSearchTopicsPayload {
  synonymMatches: [SynonymMatch!]!
}

type Mutation {
  createGithubSession(input: CreateGithubSessionInput!): CreateSessionPayload
  createGoogleSession(input: CreateGoogleSessionInput!): CreateSessionPayload
  deleteAccount(input: DeleteAccountInput!): DeleteAccountPayload
  deleteLink(input: DeleteLinkInput!): DeleteLinkPayload
  deleteSession(input: DeleteSessionInput!): DeleteSessionPayload
  deleteTopic(input: DeleteTopicInput!): DeleteTopicPayload
  removeTopicTimerange(input: RemoveTopicTimerangeInput!): RemoveTopicTimerangePayload
  reviewLink(input: ReviewLinkInput!): ReviewLinkPayload
  selectRepository(input: SelectRepositoryInput!): SelectRepositoryPayload
  updateLinkParentTopics(input: UpdateLinkParentTopicsInput!): UpdateLinkParentTopicsPayload
  updateTopicParentTopics(input: UpdateTopicParentTopicsInput!): UpdateTopicParentTopicsPayload
  updateTopicSynonyms(input: UpdateTopicSynonymsInput!): UpdateTopicSynonymsPayload
  upsertLink(input: UpsertLinkInput!): UpsertLinkPayload
  upsertTopic(input: UpsertTopicInput!): UpsertTopicPayload
  upsertTopicTimerange(input: UpsertTopicTimerangeInput!): UpsertTopicTimerangePayload
}

interface Namespaceable {
  organization: Organization!
}

type Organization {
  createdAt: DateTime!
  defaultRepository: Repository!
  id: ID
  login: String!
  name: String!
  public: Boolean!
  updatedAt: DateTime!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type QueryInfo {
  topics: TopicConnection!
  stringTokens: [String!]!
}

enum TimerangePrefixFormat {
  NONE
  START_YEAR
  START_YEAR_MONTH
}

type Query {
  # Workaround for Relay Modern weirdness
  alerts: [Alert!]!
  fakeError: String
  view(
    viewerId: ID!
    repositoryIds: [ID!],
    searchString: String,
  ): View!
}

input ReorderSynonymsInput {
  clientMutationId: String
  synonymIds: [ID!]!
  topicId: String!
}

type ReorderSynonymsPayload {
  clientMutationId: String
}

type Repository {
  displayColor: Color!
  displayName: String!
  fullName: String!
  id: String
  isPrivate: Boolean!
  name: String!
  organization: Organization!
  owner: User!
  rootTopic: Topic!
}

type RepositoryConnection {
  edges: [RepositoryEdge]
}

type RepositoryEdge {
  cursor: String!
  node: Repository!
  isSelected: Boolean!
}

input ReviewLinkInput {
  clientMutationId: String
  linkId: String!
  reviewed: Boolean!
}

type ReviewLinkPayload {
  link: Link!
}

union TopicChild = Topic | Link

type TopicChildEdge {
  cursor: String!
  node: TopicChild!
}

type TopicChildConnection {
  edges: [TopicChildEdge]
  pageInfo: PageInfo!
}

input SelectRepositoryInput {
  clientMutationId: String
  repositoryId: ID
}

type SelectRepositoryPayload {
  repository: Repository
  viewer: User!
}

type Synonym {
  locale: LocaleIdentifier!
  name: String!
}

type Topic implements Namespaceable {
  activity(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): ActivityLineItemConnection!
  availableParentTopics(
    searchString: String,
  ): LiveSearchTopicsPayload!
  children(
    searchString: String,
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicChildConnection!
  createdAt: DateTime!
  description: String
  displayColor: Color!
  displayName(
    timerange: Boolean,
  ): String!
  id: String!
  links(
    first: Int,
    after: String,
    last: Int,
    before: String,
    searchString: String,
    reviewed: Boolean,
    descendants: Boolean,
  ): LinkConnection!
  loading: Boolean!
  name: String!
  newlyAdded: Boolean!
  organization: Organization!
  parentTopics(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
  search(
    searchString: String!,
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicChildConnection!
  synonyms: [Synonym!]!
  timerange: Timerange
  updatedAt: DateTime!
  viewerCanDeleteSynonyms: Boolean!
  viewerCanUpdate: Boolean!
}

type Timerange {
  startsAt: DateTime!
  endsAt: DateTime
  prefixFormat: TimerangePrefixFormat!
}

type TopicEdge {
  cursor: String!
  node: Topic!
}

type TimerangeEdge {
  cursor: String!
  node: Timerange!
}

type TopicConnection {
  edges: [TopicEdge]
  pageInfo: PageInfo!
}

type User {
  avatarUrl: String!
  createdAt: DateTime!
  defaultRepository: Repository
  id: ID
  isGuest: Boolean!
  name: String!
  primaryEmail: String!
  repositories(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): RepositoryConnection!
  selectedRepository: Repository
  updatedAt: DateTime!
}

type UserEdge {
  cursor: String!
  node: User!
}

type Session {
  id: ID!
}

type SessionEdge {
  cursor: String!
  node: Session!
}

input SynonymInput {
  name: String!
  locale: String!
}

input UpdateTopicSynonymsInput {
  clientMutationId: String
  repoId: String!
  synonyms: [SynonymInput!]!
  topicId: String!
}

type UpdateTopicSynonymsPayload {
  alerts: [Alert!]!
  clientMutationId: String
  topic: Topic
}

input UpdateLinkParentTopicsInput {
  clientMutationId: String
  linkId: String!
  parentTopicIds: [String!]
  repoId: String!
}

type UpdateLinkParentTopicsPayload {
  link: Link!
}

input UpdateTopicParentTopicsInput {
  clientMutationId: String
  repoId: String!,
  topicId: String!
  parentTopicIds: [String!]
}

type UpdateTopicParentTopicsPayload implements Alertable {
  alerts: [Alert!]!
  topic: Topic!
}

input UpsertLinkInput {
  # This mutation is used in two contexts:
  #   - Updating a link that is known to exist.  Pass no parent topics in order to keep the existing
  #     ones.
  #   - Upserting a link that might exist.  Pass the topic under which the link is being upserted.
  # TODO: Refactor so that there's an UpsertLink mutation, which requires at least one topic, and an
  # UpdateLink mutation, which has a required link id field and doesn't modify the parent topics.
  addParentTopicId: String
  clientMutationId: String
  repoId: String!
  title: String
  url: String!
}

type UpsertLinkPayload implements Alertable {
  alerts: [Alert!]!
  linkEdge: LinkEdge
}

input UpsertTopicInput {
  clientMutationId: String
  description: String
  name: String!
  parentTopicId: String!
  repoId: String!
}

input UpsertTopicTimerangeInput {
  clientMutationId: String
  endsAt: DateTime
  prefixFormat: TimerangePrefixFormat!
  repoId: String!
  startsAt: DateTime!
  topicId: String!
}

type UpsertTopicPayload implements Alertable {
  alerts: [Alert!]!
  topicEdge: TopicEdge
}

type UpsertTopicTimerangePayload implements Alertable {
  alerts: [Alert!]!
  timerangeEdge: TimerangeEdge
  topic: Topic!
}

type ViewStats {
  calculating: Boolean!
  linkCount: Int
  topicCount: Int
}

type View {
  activity(
    first: Int,
    after: String,
    last: Int,
    before: String
    topicId: String,
  ): ActivityLineItemConnection!
  currentRepository: Repository
  defaultOrganization: Organization!
  link(id: String!): Link
  links(
    searchString: String,
    first: Int,
    after: String,
    last: Int,
    before: String,
    reviewed: Boolean,
  ): LinkConnection!
  queryInfo: QueryInfo!
  searchString: String
  stats: ViewStats!
  topic(id: String!): Topic
  topicGraph: String
  topicLiveSearch(
    searchString: String,
  ): LiveSearchTopicsPayload!
  viewer: User!
}
